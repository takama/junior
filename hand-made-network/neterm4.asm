.model small
.code
                org     100h
start:
                jmp     install
;*****************************************************************************
;-------------- ДАННЫЕ INS 6450 (National Semiconductor)
;*****************************************************************************
ACEBASE         =       02F8H                   ;базовый адрес порта COM2
RBR             =       ACEBASE                 ;регистр хранения передатчика
THR             =       ACEBASE                 ;регитр данных приемника

IER             =       ACEBASE + 1             ;регистр рахрешения прерывания
IIR             =       ACEBASE + 2             ;регистр идентификации
                                                ;прерывания
DLL             =       ACEBASE                 ;мл. регистр скорости обмена
DLM             =       ACEBASE + 1             ;ст. регистр скорости обмена

LCR             =       ACEBASE + 3             ;регистр управления линии
MCR             =       ACEBASE + 4             ;регистр управления модемом
LSR             =       ACEBASE + 5             ;регитр статуса линии

MODE            =       03H                     ;режим обмена
DIVISOR         =       80H                     ;маска на 7 бит

RRDY            =       01H                     ;готовность приемника
TRDY            =       20H                     ;готовность передатчика

ENBRI           =       01H                     ;разрешение прерываний по приему
ENBTI           =       02H                     ; - // - по передаче
DISI            =       00H                     ;запрет прерываний

ENBIGEN         =       08H                     ;использование прерываний
                                                ;в упралении модемом
BDL             =       0CH                     ;младший байт делителя скорости
BDM             =       00H                     ;старший байт делителя скорости

ERROR           =       1EH                     ;сумма кодов ошибок
;*****************************************************************************
;-------------- ДАННЫЕ PPI 8259 (Intel)
;*****************************************************************************
PICBASE         =       20H                     ;командный регистр прерываний
IMR             =       PICBASE + 1             ;регистр маски прерываний

IRQ3            =       0BH                     ;номер прерывания на IRQ3

ENB3            =       0F7H                    ;маска разрешения прерываний

DIS3            =       08H                     ;маска запрета прерываний

EOI             =       20H                     ;разрешение прерываний
;*****************************************************************************
;-------------- КОНСТАНТЫ ПРОТОКОЛА СЕТИ
;*****************************************************************************
_PRE            =       00H                     ;преамбула - начало передачи
_EOT            =       04H                     ;конец передачи
_CR             =       0DH                     ;возврат каретки
_LF             =       0AH                     ;перевод строки
_SPASE          =       20H                     ;пробел
_ESC            =       1BH                     ;конец работы
;*****************************************************************************
;-------------- COPYRIGHT
;*****************************************************************************
_copyright      db      _CR,_LF
                db      '+--------------------------------------+',CR,LF
                db      '|        Network Terminal Driver       |',CR,LF
                db      '|             Version: 0.4             |',CR,LF
                db      '| Copyright (C) 1992 by Igor Dolzhikov |',CR,LF
                db      '+--------------------------------------+',CR,LF,0
;*****************************************************************************
;-------------- МЕСТО ХРАНЕНИЯ ШТАТНОГО ОБРАБОТЧИКА ПРЕРЫВАНИЙ
;*****************************************************************************
_save_irq3o     dw      0
_save_irq3s     dw      0
;*****************************************************************************
;-------------- ПЕРЕМЕННЫЕ ПРОТОКОЛА СЕТИ
;*****************************************************************************
;-------------- буферы кадров
_rbuf           db      512 dup(0)
_tbuf           db      512 dup(0)
_tframe         db      3   dup(0)
;-------------- идентификаторы узлов
_mid            db      0
_did            db      0
_nid            db      0
;-------------- буферы однобайтовых портов
_nbyte          db      0
_tbyte          db      0
;-------------- флаги запроса сервиса
_sp             db      0
_dp             db      0
_sf             db      0
_df             db      0
_dnn            db      0
_dnid           db      0
_dtl            db      0
;-------------- флаги кодирования состояния ввода/вывода
_byi            db      0
_byd            db      0
;-------------- флаги кодирования состояния приема/передачи и переменные
_byr            db      0
_bys            db      0
_tl             db      0
_tr             db      0
_state          db      0
_rstate         db      0
;-------------- флаги состояния буферов
_rbf            db      0
_tbf            db      0
;-------------- указатели буферов
_tborg          dw      offset _tbuf
_rborg          dw      offset _rbuf
_tforg          dw      0
_tbnxt          dw      offset _tbuf + 1
_rbnxt          dw      offset _rbuf
_frnxt          dw      0
_tbend          dw      0
_rbend          dw      0
_frend          dw      0
;-------------- указатель сообщений
_txtptr         dw      0
;-------------- интерфейсные сообщения
_inpmid         db      'Input identifier main node: ',0
;*****************************************************************************
;-------------- ИНИЦИАЛИЗАЦИЯ INS 6250
;*****************************************************************************
init_ace        proc    near
                push    AX
                push    DX
                mov     DX, LCR                 ;регистр контроля линии
                mov     AL, DIVISOR             ;устанавливаем бит 7
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                mov     DX, DLM                 ;старший байт делителя
                mov     AL, BDM                 ;скорости
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                mov     DX, DLL                 ;младший байт делителя
                mov     AL, BDL                 ;скорости
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                mov     DX, LCR                 ;задание режима 8 бит,
                mov     AL, MODE                ;1 стоп бит, без контроля четн.
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                mov     DX, IER                 ;регистр разрешения прерываний
                mov     AL, DISI                ;запрет прерываний
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                pop     DX
                pop     AX
                ret
init_ace        endp
;*****************************************************************************
;-------------- РАЗРЕШЕНИЕ И ЗАПРЕТ ПРЕРЫВАНИЙ ПО ПРИЕМУ-ПЕРЕДАЧЕ
;--------------   передаваемые параметры :
;--------------     AL - содержит аргумент разрешения или запрета прерываний
;*****************************************************************************
set_ace_irqs    proc    near
                push    AX
                push    DX
                push    AX                      ;сохранение аргумента
                mov     DX, MCR                 ;регистр управления модемом
                mov     AL, ENBIGEN             ;использование прерываний
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                pop     AX                      ;восстановление аргумента
                mov     DX, IER                 ;регистр разрешения прерываний
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL                  ;посылка аргумента
                pop     DX
                pop     AX
                ret
set_ace_irqs    endp
;*****************************************************************************
;-------------- ПОЛУЧЕНИЕ ДАННЫХ ИЗ СЕТИ
;--------------   возвращаемые параметры :
;--------------     AL - содержит принятый байт
;*****************************************************************************
getc_ace        proc    near
                push    DX
                mov     DX, LSR                 ;регистр статуса линии
retry_getc:
                jmp     short $+2               ;пауза
                jmp     short $+2
                in      AL, DX
                test    AL, RRDY                ;получены ли данные?
                jz      retry_getc              ;если нет, повторить
                mov     DX, RBR                 ;регистр хранения передатчика
                jmp     short $+2               ;пауза
                jmp     short $+2
                in      AL, DX                  ;получение данных
                pop     DX
                ret
getc_ace        endp
;*****************************************************************************
;-------------- СБРОС ДАННЫХ ИЗ СЕТИ
;*****************************************************************************
clear_ace       proc    near
                push    AX
                push    DX
                mov     DX, LSR                 ;регистр статуса линии
                in      AL, DX
                test    AL, RRDY                ;получены ли данные?
                jz      no_clear                ;если нет, выйти
                mov     DX, RBR                 ;регистр хранения передатчика
                jmp     short $+2               ;пауза
                jmp     short $+2
                in      AL, DX                  ;получение данных
no_clear:
                pop     DX
                pop     AX
                ret
clear_ace       endp
;*****************************************************************************
;-------------- ПОСЫЛКА ДАННЫХ В ШИНУ
;--------------   передаваемые параметры :
;--------------     AL - содержит посылаемый байт
;*****************************************************************************
putc_ace        proc    near
                push    AX
                push    DX
                push    AX
                mov     DX, LSR                 ;регистр статуса линии
retry_putc:
                jmp     short $+2               ;пауза
                jmp     short $+2
                in      AL, DX
                test    AL, TRDY                ;готов ли передатчик
                jz      retry_putc              ;если нет, повторить
                pop     AX
                mov     DX, THR                 ;регистр данных приемника
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL                  ;посылка данных
                pop     DX
                pop     AX
                ret
putc_ace        endp
;*****************************************************************************
;-------------- ПРОВЕРКА НА ОШИБКУ В СЕТИ
;--------------   возвращаемые параметры :
;--------------     AL = 0, при отсутствии ошибки
;--------------     AL = code - код ошибки
;*****************************************************************************
error_ace       proc    near
                push    DX
                mov     DX, LSR                 ;регистр статуса линии
                jmp     short $+2               ;пауза
                jmp     short $+2
                in      AL, DX                  ;чтение статуса
                test    AL, ERROR               ;присутсвует ли ошибка?
                jnz     save_error              ;если да, то сохранение ее
                xor     AX, AX                  ;ошибки отсутсвуют AL = 0
save_error:
                pop     DX
                ret
error_ace       endp
;*****************************************************************************
;-------------- РАЗРЕШЕНИЕ ПРЕРЫВАНИЙ ПО IRQ3
;*****************************************************************************
enable_irq3     proc    near
                push    AX
                push    DX
                mov     DX, IMR                 ;регистр маски прерываний
                in      AL, DX
                and     AL, ENB3                ;наложение маски
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                pop     DX
                pop     AX
                ret
enable_irq3     endp
;*****************************************************************************
;-------------- ЗАПРЕТ ПРЕРЫВАНИЙ ПО IRQ3
;*****************************************************************************
disable_irq3    proc    near
                push    AX
                push    DX
                mov     DX, IMR                 ;регистр маски прерываний
                in      AL, DX
                or      AL, DIS3                ;наложение маски
                jmp     short $+2               ;пауза
                jmp     short $+2
                out     DX, AL
                pop     DX
                pop     AX
                ret
disable_irq3    endp
;*****************************************************************************
;-------------- ОКОНЧАНИЕ ПРЕРЫВАНИЯ
;*****************************************************************************
clr_ints        proc    near
                push    AX
                push    DX
                mov     DX, PICBASE             ;командный регистр прерываний
                mov     AL, EOI
                out     DX, AL
                pop     DX
                pop     AX
                ret
clr_ints        endp
;*****************************************************************************
;-------------- ВОЗВРАТ АДРЕСА ПРЕРЫВАНИЯ
;--------------   передаваемые параметры :
;--------------     AL - номер прерывания
;--------------   возвращаемые параметры : DX:CX
;--------------     CX - младший байт адреса вектора прерывания
;--------------     DX - старший байт адреса вектора прерывания
;*****************************************************************************
interrupt_get   proc    near
                push    AX
                push    BX
                push    DS
                mov     AH, 0
                shl     AX, 1                   ;адрес вектора AX * 4
                shl     AX, 1
                mov     BX, AX                  ;BX - адрес вектора
                xor     AX, AX                  ;AX = 0
                mov     DS, AX                  ;DS = 0
                cli
                mov     CX, [BX]                ;CX - смещение вектора
                mov     DX, [BX+2]              ;DX - сегмент вектора
                sti
                pop     DS
                pop     BX
                pop     AX
                ret
interrupt_get   endp
;*****************************************************************************
;-------------- УСТАНОВКА НОВОГО ОБРАБОТЧИКА ПРЕРЫВАНИЯ
;--------------   передаваемые параметры : DX:CX
;--------------     AL - номер прерывания
;--------------     CX - младший байт адреса вектора прерывания
;--------------     DX - старший байт адреса вектора прерывания
;*****************************************************************************
interrupt_set   proc    near
                push    AX
                push    BX
                push    DS
                mov     AH, 0
                shl     AX, 1                   ;адрес вектора AX * 4
                shl     AX, 1
                mov     BX, AX                  ;BX - адрес вектора
                xor     AX, AX                  ;AX = 0
                mov     DS, AX                  ;DS = 0
                cli
                mov     [BX], CX                ;[BX]   - смещение вектора
                mov     [BX+2], DX              ;[BX+2] - сегмент вектора
                sti
                pop     DS
                pop     BX
                pop     AX
                ret
interrupt_set   endp
;*****************************************************************************
;-------------- ЧТЕНИЕ КЛАВИШИ
;--------------   возвращаемые параметры :
;--------------     AL - содержит код знака
;--------------     AH - скэн код клавиши
;--------------     AX = 0 клавиша не нажата
;*****************************************************************************
kbdhit          proc    near
                mov     AH, 1                   ;функция опроса клавиатуры
                int     16H                     ;без ожидания
                jz      no_key
                mov     AH, 0                   ;чтение скэн-кода
                int     16H
                jmp     short yes
no_key:
                xor     AX, AX
yes:
                ret
kbdhit          endp
;*****************************************************************************
;-------------- ВЫВОД БАЙТА НА ЭКРАН
;--------------   передаваемые параметры :
;--------------     AL - выводимый байт
;*****************************************************************************
putch           proc    near
                push    AX
                push    BX
                mov     AH, 0EH                 ;функция вывода в режиме
                xor     BX, BX                  ;телетайпа
                int     10H
                pop     BX
                pop     AX
                ret
putch           endp
;*****************************************************************************
;-------------- ВЫВОД СТРОКИ НА ЭКРАН
;--------------   передаваемые параметры :
;--------------     _txtptr - смещение выводимой строки (последний элемент 0)
;*****************************************************************************
display_txt     proc    near
                push    AX
                push    BX
                push    SI
                mov     SI, _txtptr             ;SI - указатель сообщения
write:
                lodsb
                or      AL, AL
                jz      end_write
                mov     AH, 0EH                 ;функция вывода в режиме
                xor     BX, BX                  ;телетайпа
                int     10H
                jmp     short write
end_write:
                pop     SI
                pop     BX
                pop     AX
                ret
display_txt     endp
;*****************************************************************************
;-------------- УСТАНОВКА НОВОГО ОБРАБОТЧИКА ПРЕРЫВАНИЙ
;*****************************************************************************
setup_irq3      proc    near
                push    AX
                push    CX
                push    DX
                mov     AL, IRQ3                ;установка прерывания на IRQ4
                call    interrupt_get
                mov     _save_irq3o, CX         ;записать смещение
                mov     _save_irq3s, DX         ;записать сегмент
                mov     CX, offset nisr         ;установить новое смещение
                mov     DX, DS                  ;установить новый сегмент
                call    interrupt_set
                pop     DX
                pop     CX
                pop     AX
                ret
setup_irq3      endp
;*****************************************************************************
;-------------- ВОСТАНОВЛЕНИЕ ШТАТНОГО ОБРАБОТЧИКА ПРЕРЫВАНИЙ
;*****************************************************************************
restore_irq3    proc    near
                push    AX
                push    CX
                push    DX
                mov     AL, IRQ3                ;прерывание на IRQ3
                mov     CX, _save_irq3o         ;востановить штатное смещение
                mov     DX, _save_irq3s         ;востановить штатное сегмент
                call    interrupt_set
                pop     DX
                pop     CX
                pop     AX
                ret
restore_irq3    endp
;*****************************************************************************
;-------------- ОБРАБОТЧИК ПРЕРЫВАНИЯ ПО IRQ3
;*****************************************************************************
nisr            proc    far
                sti                             ;разрешение немаскируемых
                cld                             ;прерываний и сброс флага
                push    DS                      ;направления
                push    ES
                push    CS                      ;установка сегмента данных
                pop     DS                      ;и дополнительного сегмента
                push    CS                      
                pop     ES
                cmp     _bys, 1                 ;проверить сигнал занятости
                jnz     rec                     ;передачи
                call    transmit                ;если есть сигнал, то передача
                jmp     short end_nisr
rec:
                call    receive                 ;если нет сигнала, то прием
end_nisr:
                pop     ES
                pop     DS
                cli
                call    clr_ints                ;сообщить об окончании
                iret                            ;прерывания
nisr            endp
;*****************************************************************************
;--------------  ПРИЕМ БАЙТА
;*****************************************************************************
receive         proc    near
                push    AX
                call    getc_ace                ;принять символ
                mov     _nbyte, AL              ;запомнить его
                call    error_ace               ;проверить на ошибку
                cmp     AL, 0
                jnz     end_receive             ;если ошибка, то выход
                cmp     _nbyte, _PRE            ;если это не _PRE
                jnz     next_receive1           ;продолжить дальше
                call    PRE_received            ;отметить получение _PRE
                jmp     short end_receive
next_receive1:
                cmp     _rstate, 1              ;если не получен 2-ой байт
                jnz     next_receive2           ;пакета продолжить дальше
                call    DID_received            ;проверить адрес сообщения
                jmp     short end_receive
next_receive2:
                cmp     _rstate, 2              ;если не прием пакета
                jnz     next_receive3           ;продолжить дальше
                call    accept                  ;продолжить прием пакета
                jmp     short end_receive
next_receive3:
                mov     _rstate, 0              ;сбросить состояние 'прием'
end_receive:
                pop     AX
                ret
receive         endp
;*****************************************************************************
;-------------- ПОЛУЧЕНИЕ ПРЕАМБУЛЫ
;*****************************************************************************
PRE_received    proc    near
                push    AX
                cmp     _rstate, 0              ;если получен неожидаемый байт
                jz      set_rstate              ;_PRE а буфер _rbuf пуст
                cmp     _rbf, 0                 ;реаницилизировать указатель
                jnz     set_rstate              ;буфер _rbuf
                mov     AX, _rborg
                mov     _rbnxt, AX              ;установить _rbnxt = _rborg
set_rstate:
                mov     _rstate, 1              ;начать ожидание байта _did
                pop     AX
                ret
PRE_received    endp
;*****************************************************************************
;-------------- ПОЛУЧЕНИЕ АДРЕСА СООБЩЕНИЯ
;*****************************************************************************
DID_received    proc    near
                push    AX
                mov     AL, _mid
                cmp     _nbyte, AL              ;если получен _mid и буфер _rbuf
                jnz     init_rstate             ;свободен начать прием пакета
                cmp     _rbf, 0
                jnz     init_rstate
                mov     _rstate, 2
                jmp     short beg_rec
init_rstate:
                mov     _rstate, 0              ;начать ожидание байта _PRE
beg_rec:
                pop     AX
                ret
DID_received    endp
;*****************************************************************************
;-------------- ОБРАБОТКА БАЙТА, ПОЛУЧЕННОГО ИЗ СЕТИ
;*****************************************************************************
accept          proc    near
                push    AX
                push    DI
                mov     DI, _rbnxt              ;загрузить адрес след. байта
                cmp     _nbyte, _EOT            ;если не конец приема,
                jnz     no_end                  ;то, переход
                mov     _dp, 1                  ;установить _dp = 1
                mov     _rbf, 1                 ;установить _rbf = 1
                mov     _rstate, 0              ;установить _rstate = 0
                mov     _rbend, DI              ;установить _rbend = _rbnxt
                mov     AX, _rborg
                mov     _rbnxt, AX              ;установить _rbnxt = _rborg
                jmp     short end_accept        ;перейти на конец приема
no_end:
                mov     AL, _nbyte              ;загрузить байт
                stosb
                mov     _rbnxt, DI              ;запомнить указатель на сл. байт
end_accept:
                pop     DI
                pop     AX
                ret
accept          endp
;*****************************************************************************
;--------------  ПЕРЕДАЧА БАЙТА
;*****************************************************************************
transmit        proc    near
                push    AX
                push    SI
                mov     SI, _tbnxt              ;загрузить адрес след. байта
                cmp     SI, _tbend              ;если это не конец передачи
                jnz     next_transmit           ;перейти дальше
                mov     _bys, 0                 ;установить _bys = 0
                mov     _tbf, 0                 ;установить _tbf = 0
                mov     AX, _tborg
                inc     AX
                mov     _tbnxt, AX              ;установить _tbnxt = _tborg + 1
                call    enable_receive          ;разрешить прием
                jmp     short end_transmit      ;перейти на конец передачи
next_transmit:
                lodsb                           ;загрузить след. байт
                call    putc_ace                ;передать его в сеть
                mov     _tbnxt, SI              ;установить указатель на
end_transmit:                                   ;следующий байт
                pop     SI
                pop     AX
                ret
transmit        endp
;*****************************************************************************
;-------------- РАЗРЕШЕНИЕ ПРИЕМА
;*****************************************************************************
enable_receive  proc    near
                push    AX
                call    clear_ace               ;освободить буфер ACE
                call    clear_ace
                call    clear_ace
                mov     AL, ENBRI
                call    set_ace_irqs            ;разрешить прерывания приема
                pop     AX
                ret
enable_receive  endp
;*****************************************************************************
;-------------- ИНИЦИАЛИЗАЦИЯ
;*****************************************************************************
initialize      proc    near
                push    AX
                push    BX
                mov     BX, _tborg              ;поместить в первый байт
                mov     byte ptr [BX], _PRE     ;буфера _PRE (преамбулу)
                call    init_ace                ;инициализация Intel 8250
                mov     AL, ENBRI
                call    set_ace_irqs            ;разрешить прерывания по приему
                call    setup_irq3              ;установить новый обработчик
                call    clr_ints                ;сбросить прерывания
                call    enable_irq3             ;разрешить прерывания по IRQ3
                pop     BX
                pop     AX
                ret
initialize      endp
;*****************************************************************************
;-------------- ПЛАНИРОВЩИК
;--------------   возвращаемые параметры :
;--------------     AL - код выхода
;--------------     AL = 0 - продолжение работы
;--------------     AL = 1 - конец работы
;*****************************************************************************
schedule        proc    near
                cmp     _sp, 1                  ;пров. запрос на посылку пакета
                jnz     next_if_1               ;если запрос отсутсвует, переход
                cmp     _rstate, 0              ;пров. сигнал занятости приема
                jnz     next_if_1               ;если процесс занят, переход
                call    start_send              ;подготовить передачу пакета
next_if_1:
                cmp     _dp, 1                  ;пров. запрос на отображение
                jnz     next_if_2               ;если запрос отсутсвует, переход
                cmp     _byi, 0                 ;пров. сигнал занятости ввода
                jnz     next_if_2               ;если процесс занят, переход
                call    output                  ;вывод  пакета
next_if_2:
                call    kbdhit                  ;проверка наличия введенного
                or      AX, AX                  ;байта
                jz      end_schedule            ;если отсутсвует, то переход
                mov     _tbyte, AL              ;записать прочитанный байт
                cmp     AX, 011BH               ;проверить на _ESC
                jz      end_schedule            ;выход из процедуры, если _ESC
                call    input                   ;ввод байта в буфер для передачи
                xor     AL, AL                  ;установка кода возврата
end_schedule:
                ret
schedule        endp
;*****************************************************************************
;-------------- ВОССТАНОВЛЕНИЕ РЕЖИМА РАБОТЫ
;*****************************************************************************
restore         proc    near
                call    disable_irq3            ;маска запрета прерываний
                call    restore_irq3            ;восстановление вектора
                ret
restore         endp
;*****************************************************************************
;-------------- НАЧАЛО ПЕРЕДАЧИ ПАКЕТА
;*****************************************************************************
start_send      proc    near
                push    AX
                mov     _bys, 1                 ;сигнал о занятости передачи
                mov     _sp, 0                  ;запрос на посылку пакета
                mov     AL, ENBTI
                call    set_ace_irqs            ;разрешение прерываний
                pop     AX                      ;по передаче
                ret
start_send      endp
;*****************************************************************************
;-------------- ВВОД ПАКЕТА
;*****************************************************************************
input           proc    near
                push    AX
                push    DI
                cmp     _tbf, 0                 ;пров. заполнен ли буфер приема
                jnz     end_input               ;если заполнен, то выход
                cmp     _byi, 0                 ;пров. сигнал занятости ввода
                jnz     active                  ;если занято, не устанавливать
                mov     _byi, 1                 ;установить сигнал
                mov     AL, _tbyte              ;подготовить байт для ввода
                call    putch                   ;отобразить его
                mov     DI, _tbnxt              ;загрузить did в буфер
                stosb
                mov     _tbnxt, DI              ;возвратить инкремент адреса
                mov     AL, _mid
                stosb                           ;загрузить _mid
                mov     _tbnxt, DI              ;возвратить инкремент адреса
                jmp     short end_input
active:
                mov     AL, _tbyte              ;подготовить байт для ввода
                call    putch                   ;отобразить его
                mov     DI, _tbnxt              ;загрузить его в буфер
                stosb
                mov     _tbnxt, DI              ;возвратить инкремент адреса
                cmp     AL, _CR                 ;проверить на _CR
                jnz     end_input               ;если не _CR, то переход
                mov     AL, _LF                 ;отобразить _LF
                call    putch
                stosb                           ;загрузить _LF
                mov     AL, _EOT
                stosb                           ;загрузить _EOT
                mov     _sp, 1                  ;установить _sp = 1
                mov     _tbf, 1                 ;установить _tbf = 1
                mov     _byi, 0                 ;установить _byi = 0
                mov     _tbend, DI              ;установить _tbend = _tbnxt
                mov     AX, _tborg
                mov     _tbnxt, AX              ;установить _tbnxt = _tborg
end_input:
                pop     DI
                pop     AX
                ret
input           endp
;*****************************************************************************
;-------------- ВЫВОД ПАКЕТА
;*****************************************************************************
output          proc    near
                push    AX
                push    SI
                mov     _dp, 0                  ;сбросить запрос на отображение
                mov     SI, _rbnxt              ;загрузить адрес буфера приема
retry_output:
                cmp     SI, _rbend              ;сравнить с указателем конца
                jae     end_output              ;если конец, то переход
                lodsb                           ;загрузить байт
                call    putch                   ;отобразить его
                jmp     short retry_output      ;повторить сначала
end_output:
                mov     _rbf, 0                 ;буфер приема теперь свободен
                mov     AX, _rborg              ;установить _rbnxt = _rborg
                mov     _rbnxt, AX
                pop     SI
                pop     AX
                ret
output          endp
;*****************************************************************************
;-------------- ВВОД ИДЕНТИФИКАТОРА УЗЛА
;*****************************************************************************
input_MID       proc    near
                push    AX
                mov     AX, offset _inpmid      ;присвоить указателю сообщение
                mov     _txtptr, AX             ;_txtptr^ = _inpmid
                call    display_txt             ;отобразить сообщение
                call    input_byte              ;считать _mid
                mov     AL, _tbyte              ;установить идентификатор узла
                mov     _mid, AL                ;_mid = _tbyte
                call    end_display             ;перевести курсор в начало
                pop     AX                      ;следующей строки
                ret
input_MID       endp
;*****************************************************************************
;-------------- ВВОД БАЙТА
;--------------   возвращаемые параметры:
;--------------     _tbyte - введенный байт
;*****************************************************************************
input_byte      proc    near
                push    AX
wait_key:
                call    kbdhit                  ;ждать нажатия клавиши
                cmp     AX, 0
                jz      wait_key
                mov     _tbyte, AL              ;запомнить введенный байт
                pop     AX
                ret
input_byte      endp
;*****************************************************************************
;-------------- ОКНЧАНИЕ ОТОБРАЖЕНИЯ
;*****************************************************************************
end_display     proc    near
                push    AX
                mov     AL, _tbyte              ;отобразить введенный байт
                call    putch
                mov     AL, _CR                 ;отобразить _CR
                call    putch
                mov     AL, _LF                 ;отобразить _LF
                call    putch
                pop     AX
                ret
end_display     endp
;*****************************************************************************
;-------------- НАЧАЛО ПРОГРАММЫ
;*****************************************************************************
install:
                mov     AX, offset _copyright   ;присвоить указателю сообщение
                mov     _txtptr, AX             ;_txtptr^ = _copyright
                call    display_txt             ;отобразить сообщение
                call    input_MID               ;ввести идентификатор узла
                call    initialize              ;инициализация
retry:
                call    schedule                ;запуск планировщика
                cmp     AL, 0                   ;если код возврата равен 0
                jz      retry                   ;продолжение работы
                call    restore                 ;восстановить режим работы
;*****************************************************************************
;-------------- ВЫХОД ИЗ ПРОГРАММЫ
;*****************************************************************************
                int     20H
                end     start
